# Python Day9
# ! Eg:3
#class parent:
#    name = "sri"

#class child(parent):
#   name = "Prabha"
    
#    def display(self):
#       print(self.name)

#d = child()
#d.display()

# Multi Level Inheritance
# ! Eg:1

#class voice:
#    def sound(self):
#        print("All the animals have their own voices")

#class dog(voice):
#    def odg_voice(self):
#        print("bark")

#class cat(dog):
#    def cat_voice(self):
#        print("meow")

#class parrot(cat):
#    def parrot_voice(self):
#        print("speak")

#all = parrot()
#all.dog_voice()
#all.cat_voice()
#all.sound_voice()
#all.parrot_voice()

# ? Eg:2
##class honda_city:
##    def hondaengine_specs(self, cc, hp, torque, fuel_type, num_of_piston)
##        print(self, cc, hp, torque, fuel_type, num_of_piston)
##    
#  !--------------->
# !multiple inheritance
# ? it has multiple parent and 1 child
##class white_petrol:
##    def function_o(self):
##        print("aeroplans")
##
##class Organic_petrol:
##    def function_o(self):
##        print("used for Bike, cars")
##
##class premium_petrol:
##    def function_p(self):
##        print("spots cars, bikes'
##
##class petrol (while_pertol, Organic_petrol, premium_petrol):
##    def defanition(self):
##        print("Petrols types")
##p- petrol()
##p.defanition()
##p.function_o()


# ! Heirarical inheritance

#class catagory:
#   def cat_name(self):
#       print("Vegetables")

#class Tomato:
#    def tomato specs(self):
#        color="black"
#        taste ="neutral taste"
#       self.display(colour, taste):
#class carrot:
#    def carrot specs(self):
#        color="orange"
#        taste ="sweet"

#c carrot()
#c.carrot_specs()
#c.weight("30gms")
#t = Tomato()
#t.tomato_specs()
#t.weight("20gms")

# ! hybrid inheritance

#class c1:
 #   def m1(self):
 #       print("class1")

#class c2:
#    def m2(self):
#        print("class2")

#class c3:
#    def m3(self):
#        print("class3")

#class c4:
#    def m4(self):
#        print("class4")

#class c5:
#    def m5(self):
#        print("class5")

#class c6:
#    def m6(self):
#       print("class6")

#obj = c6()
#obj.m3()


# ! ----------> polymorphism
# ? poly - many, morph --->
# a function which has the ability to perform more than 1 functionality
# then it is considered to be as polymorphism

# * polymorphism in builtin functions
# len() --> which is used to find the length of list,tuple,dict etc..
# index()
# max()
# min()'# count()
# pop()
# and more...

# * polymorphism in operator
# *
# print(8+8)
# print("k"+"l")
# print([1,2,3]+[5,6])

# print(6*7)
#1112,3,4,5,6)
# print(*11)
# def f1(*args)
# 11 = [1,2,3,4]
#print(11*10)

# Ploymorphism in classes
# We can achieve polymorphism in 2 ways
#1.) Method overloading it is not possible in python
#2.) Method overriding

#d1 = {"shirt": 1000, "pant": 1500, "shoes": 900, "handkey": 30}
#1.) find the min ans max priced product
#2.) find the product starts with 's' and 's'

# 2.) find the n = 67, is strong number or not

# 3.) 11 = [1,2,3,4,5,6]
# n = 2 --> [5,6,1,2,3,4,]
# n = 3 ---> [4,5,6,1,2,3]











































    
